'use server'

import { createSupabaseServerClient, createSupabaseAdminClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { z } from 'zod'
import { revalidatePath } from 'next/cache'
import { SurfSchool, Gallery } from '@/lib/database.types'

// Debug function to check env vars
export async function checkEnvironmentVariables() {
  console.log('üîç Environment check:')
  console.log('NEXT_PUBLIC_SUPABASE_URL:', process.env.NEXT_PUBLIC_SUPABASE_URL ? '‚úÖ Set' : '‚ùå Missing')
  console.log('NEXT_PUBLIC_SUPABASE_ANON_KEY:', process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ? '‚úÖ Set' : '‚ùå Missing')
  console.log('SUPABASE_SERVICE_ROLE_KEY:', process.env.SUPABASE_SERVICE_ROLE_KEY ? '‚úÖ Set' : '‚ùå Missing')
  
  return {
    supabaseUrl: !!process.env.NEXT_PUBLIC_SUPABASE_URL,
    anonKey: !!process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    serviceKey: !!process.env.SUPABASE_SERVICE_ROLE_KEY
  }
}

// Nouvelles Server Actions pour r√©cup√©rer les donn√©es
export async function fetchSurfSchools(): Promise<SurfSchool[]> {
  try {
    console.log('üèÑ‚Äç‚ôÇÔ∏è Attempting to fetch surf schools...')
    
    // V√©rifier les variables d'environnement avant de cr√©er le client
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
      console.error('‚ùå Missing required environment variables')
      console.log('URL:', !!process.env.NEXT_PUBLIC_SUPABASE_URL)
      console.log('Service Key:', !!process.env.SUPABASE_SERVICE_ROLE_KEY)
      return []
    }
    
    const supabaseAdmin = createSupabaseAdminClient()
    console.log('‚úÖ Supabase admin client created successfully')
    
    const { data: schools, error } = await supabaseAdmin
      .from('surf_schools')
      .select('id, name, slug')
      .order('name', { ascending: true })
    
    if (error) {
      console.error('‚ùå Error fetching surf schools:', error)
      return []
    }
    
    console.log('‚úÖ Surf schools fetched successfully:', schools?.length || 0)
    return schools || []
  } catch (error) {
    console.error('üí• Unexpected error in fetchSurfSchools:', error)
    return []
  }
}

export async function fetchGalleries(): Promise<Gallery[]> {
  try {
    console.log('üñºÔ∏è Attempting to fetch galleries...')
    
    // V√©rifier les variables d'environnement avant de cr√©er le client
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
      console.error('‚ùå Missing required environment variables for galleries')
      return []
    }
    
    const supabaseAdmin = createSupabaseAdminClient()
    console.log('‚úÖ Supabase admin client created for galleries')
    
    const { data: galleries, error } = await supabaseAdmin
      .from('galleries')
      .select('id, name, date, school_id, created_at')
      .order('created_at', { ascending: false })
    
    if (error) {
      console.error('‚ùå Error fetching galleries:', error)
      return []
    }
    
    console.log('‚úÖ Galleries fetched successfully:', galleries?.length || 0)
    return galleries || []
  } catch (error) {
    console.error('üí• Unexpected error in fetchGalleries:', error)
    return []
  }
}

// Sch√©ma de validation c√¥t√© serveur
const uploadServerSchema = z.object({
  school_id: z.number().min(1, "√âcole de surf requise"),
  gallerySelection: z.string().min(1, "S√©lection de galerie requise"),
  newGalleryName: z.string().optional(),
  galleryDate: z.string().min(1, "Date requise"),
  originalFiles: z.array(z.instanceof(File)).min(1, "Au moins un fichier original requis"),
  previewFiles: z.array(z.instanceof(File)).min(1, "Au moins un fichier preview requis"),
})

// Type de retour pour le Server Action
interface UploadResult {
  success: boolean
  error?: string
  uploadedCount?: number
}

export async function uploadPhotos(formData: FormData): Promise<UploadResult> {
  try {
    // V√©rifier l'authentification
    const supabase = await createSupabaseServerClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      redirect('/login')
    }

    // Client admin pour les op√©rations de base de donn√©es
    const adminSupabase = createSupabaseAdminClient()

    // Extraire et valider les donn√©es du FormData
    const schoolId = parseInt(formData.get('school_id') as string)
    const gallerySelection = formData.get('gallerySelection') as string
    const newGalleryName = formData.get('newGalleryName') as string | null
    const galleryDate = formData.get('galleryDate') as string
    const originalFiles = formData.getAll('originalFiles') as File[]
    const previewFiles = formData.getAll('previewFiles') as File[]

    // Validation avec Zod
    const validationResult = uploadServerSchema.safeParse({
      school_id: schoolId,
      gallerySelection,
      newGalleryName: newGalleryName || undefined,
      galleryDate,
      originalFiles,
      previewFiles,
    })

    if (!validationResult.success) {
      return {
        success: false,
        error: 'Donn√©es de formulaire invalides: ' + validationResult.error.issues.map(i => i.message).join(', ')
      }
    }

    const { school_id, gallerySelection: selectedGallery, newGalleryName: newName, galleryDate: date } = validationResult.data

    // V√©rifier que l'√©cole de surf existe
    const { data: surfSchool, error: schoolError } = await adminSupabase
      .from('surf_schools')
      .select('id, name')
      .eq('id', school_id)
      .single()

    if (schoolError || !surfSchool) {
      return {
        success: false,
        error: '√âcole de surf s√©lectionn√©e introuvable'
      }
    }

    // Valider que le nombre de fichiers correspond
    if (originalFiles.length !== previewFiles.length) {
      return {
        success: false,
        error: `Nombre de fichiers diff√©rent: ${originalFiles.length} originaux, ${previewFiles.length} previews`
      }
    }

    // Trier les fichiers par nom pour garantir l'appariement
    const sortedOriginals = originalFiles.sort((a, b) => a.name.localeCompare(b.name))
    const sortedPreviews = previewFiles.sort((a, b) => a.name.localeCompare(b.name))

    // V√©rifier que les noms correspondent (optionnel, pour une validation suppl√©mentaire)
    for (let i = 0; i < sortedOriginals.length; i++) {
      const originalName = sortedOriginals[i].name
      const previewName = sortedPreviews[i].name
      
      if (originalName !== previewName) {
        console.warn(`Fichiers non-correspondants √† l'index ${i}: ${originalName} vs ${previewName}`)
        // On continue quand m√™me - l'utilisateur a √©t√© pr√©venu c√¥t√© client
      }
    }

    // G√©rer la galerie (cr√©er ou utiliser existante)
    let galleryId: string

    if (selectedGallery === 'new') {
      if (!newName?.trim()) {
        return {
          success: false,
          error: 'Le nom de la nouvelle galerie est requis'
        }
      }

      // Cr√©er une nouvelle galerie avec school_id
      const { data: newGallery, error: galleryError } = await adminSupabase
        .from('galleries')
        .insert({
          name: newName.trim(),
          date: date,
          school_id: school_id,
        })
        .select('id')
        .single()

      if (galleryError || !newGallery) {
        console.error('Gallery creation error:', galleryError)
        return {
          success: false,
          error: 'Erreur lors de la cr√©ation de la galerie: ' + (galleryError?.message || 'Erreur inconnue')
        }
      }

      galleryId = newGallery.id
    } else {
      // V√©rifier que la galerie existe et appartient √† la bonne √©cole
      const { data: existingGallery, error: galleryCheckError } = await adminSupabase
        .from('galleries')
        .select('id, school_id')
        .eq('id', selectedGallery)
        .eq('school_id', school_id)
        .single()

      if (galleryCheckError || !existingGallery) {
        return {
          success: false,
          error: 'Galerie s√©lectionn√©e introuvable ou incompatible avec l\'√©cole'
        }
      }

      galleryId = existingGallery.id
    }

    // Traiter chaque paire de fichiers
    let uploadedCount = 0
    
    for (let i = 0; i < sortedOriginals.length; i++) {
      const originalFile = sortedOriginals[i]
      const previewFile = sortedPreviews[i]
      
      try {
        // Valider les types de fichiers
        if (!originalFile.type.startsWith('image/') || !previewFile.type.startsWith('image/')) {
          throw new Error(`Fichiers ${originalFile.name}/${previewFile.name} ne sont pas des images`)
        }

        // G√©n√©rer un nom de fichier unique bas√© sur l'index et timestamp
        const timestamp = Date.now()
        const uniqueId = `${galleryId.replace(/-/g, '')}_${timestamp}_${i.toString().padStart(3, '0')}`
        const originalExtension = originalFile.name.split('.').pop() || 'jpg'
        const previewExtension = previewFile.name.split('.').pop() || 'jpg'
        
        const originalFileName = `${uniqueId}_original.${originalExtension}`
        const previewFileName = `${uniqueId}_preview.${previewExtension}`

        // Lire les fichiers
        const originalBuffer = Buffer.from(await originalFile.arrayBuffer())
        const previewBuffer = Buffer.from(await previewFile.arrayBuffer())

        // Upload de l'image originale vers Supabase Storage (bucket priv√©)
        const { data: originalUpload, error: originalError } = await adminSupabase.storage
          .from('originals')
          .upload(`gallery-${galleryId}/${originalFileName}`, originalBuffer, {
            contentType: originalFile.type,
            upsert: false
          })

        if (originalError) {
          throw new Error(`Erreur upload original ${originalFile.name}: ${originalError.message}`)
        }

        // Upload de l'image preview vers Supabase Storage (bucket public)
        const { data: previewUpload, error: previewError } = await adminSupabase.storage
          .from('web-previews')
          .upload(`gallery-${galleryId}/${previewFileName}`, previewBuffer, {
            contentType: previewFile.type,
            upsert: false
          })

        if (previewError) {
          // Si preview √©choue, nettoyer l'original d√©j√† upload√©
          await adminSupabase.storage
            .from('originals')
            .remove([originalUpload.path])
          throw new Error(`Erreur upload preview ${previewFile.name}: ${previewError.message}`)
        }

        // Obtenir l'URL publique de la preview
        const { data: previewUrl } = adminSupabase.storage
          .from('web-previews')
          .getPublicUrl(previewUpload.path)

        // Enregistrer les m√©tadonn√©es dans Supabase (utiliser les noms de colonnes du sch√©ma existant)
        const { error: photoError } = await adminSupabase
          .from('photos')
          .insert({
            gallery_id: galleryId,
            original_s3_key: originalUpload.path,
            preview_s3_url: previewUrl.publicUrl,
            filename: originalFile.name,
            filesize: originalFile.size,
            content_type: originalFile.type,
          })

        if (photoError) {
          console.error('Photo metadata save error:', photoError)
          // Nettoyer les fichiers upload√©s si l'insertion DB √©choue
          await Promise.all([
            adminSupabase.storage.from('originals').remove([originalUpload.path]),
            adminSupabase.storage.from('web-previews').remove([previewUpload.path])
          ])
          throw new Error(`Erreur lors de la sauvegarde des m√©tadonn√©es pour ${originalFile.name}`)
        }

        uploadedCount++
      } catch (error) {
        console.error(`Error processing file pair ${i}:`, error)
        // Continue avec les autres fichiers mais log l'erreur
        // L'utilisateur recevra le compte des fichiers r√©ussis
      }
    }

    // Invalider le cache de la page admin
    revalidatePath('/admin/upload')

    return {
      success: true,
      uploadedCount
    }

  } catch (error) {
    console.error('Upload action error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Erreur inconnue lors de l\'upload'
    }
  }
} 